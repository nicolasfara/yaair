<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/rufi/aggregate.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/rufi/aggregate.rs" />
              <option name="originalContent" value="use crate::rufi::alignment::alignment_stack::AlignmentStack;&#10;use crate::rufi::data::field::Field;&#10;use crate::rufi::data::state::State;&#10;use crate::rufi::messages::inbound::InboundMessage;&#10;use crate::rufi::messages::outbound::OutboundMessage;&#10;use crate::rufi::messages::path::Path;&#10;use crate::rufi::messages::serializer::Serializer;&#10;use alloc::boxed::Box;&#10;use alloc::format;&#10;use alloc::vec::Vec;&#10;use core::hash::Hash;&#10;use serde::{Deserialize, Serialize};&#10;&#10;pub trait Aggregate&lt;Id: Ord + Hash + Copy + Serialize&gt; {&#10;    fn neighboring&lt;V&gt;(&amp;mut self, value: V) -&gt; Field&lt;Id, V&gt;&#10;    where&#10;        V: Serialize + for&lt;'de&gt; Deserialize&lt;'de&gt; + Clone + 'static;&#10;&#10;    fn repeat&lt;V, F&gt;(&amp;mut self, initial: V, evolution: F) -&gt; V&#10;    where&#10;        V: Clone + 'static,&#10;        F: FnOnce(V, &amp;mut Self) -&gt; V;&#10;&#10;    fn branch&lt;V, Th, El&gt;(&amp;mut self, condition: bool, th: Th, el: El) -&gt; V&#10;    where&#10;        Th: FnOnce(&amp;mut Self) -&gt; V,&#10;        El: FnOnce(&amp;mut Self) -&gt; V;&#10;}&#10;&#10;pub struct VM&lt;Id: Ord + Hash + Copy + Serialize, S: Serializer&gt; {&#10;    pub local_id: Id,&#10;    state: State,&#10;    inbound: InboundMessage&lt;Id&gt;,&#10;    outbound: OutboundMessage&lt;Id&gt;,&#10;    alignment_stack: AlignmentStack,&#10;    serializer: S,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy + Serialize, S: Serializer&gt; VM&lt;Id, S&gt; {&#10;    pub fn new(local_id: Id, serializer: S) -&gt; Self {&#10;        Self {&#10;            local_id,&#10;            state: State::default(),&#10;            inbound: InboundMessage::default(),&#10;            outbound: OutboundMessage::empty(local_id),&#10;            alignment_stack: AlignmentStack::new(),&#10;            serializer,&#10;        }&#10;    }&#10;&#10;    pub fn new_with_state(local_id: Id, serializer: S, state: State) -&gt; Self {&#10;        Self {&#10;            local_id,&#10;            state,&#10;            inbound: InboundMessage::default(),&#10;            outbound: OutboundMessage::empty(local_id),&#10;            alignment_stack: AlignmentStack::new(),&#10;            serializer,&#10;        }&#10;    }&#10;&#10;    pub fn get_outbound(&amp;self) -&gt; Vec&lt;u8&gt; {&#10;        match self.serializer.serialize(&amp;self.outbound) {&#10;            Ok(serialized) =&gt; serialized,&#10;            Err(err) =&gt; panic!(&quot;Failed to serialize outbound message: {}&quot;, err),&#10;        }&#10;    }&#10;&#10;    pub fn set_inbound(&amp;mut self, inbound: InboundMessage&lt;Id&gt;) {&#10;        self.inbound = inbound;&#10;    }&#10;}&#10;impl&lt;Id: Ord + Hash + Copy + Serialize, S: Serializer&gt; Aggregate&lt;Id&gt; for VM&lt;Id, S&gt; {&#10;    fn neighboring&lt;V&gt;(&amp;mut self, value: V) -&gt; Field&lt;Id, V&gt;&#10;    where&#10;        V: Serialize + for&lt;'de&gt; Deserialize&lt;'de&gt; + Clone + 'static,&#10;    {&#10;        self.alignment_stack.align(&quot;neighboring&quot;);&#10;        let path = Path::new(self.alignment_stack.current_path());&#10;        let result: Field&lt;Id, V&gt; = Field::new(&#10;            value.clone(),&#10;            self.inbound&#10;                .get_at_path(&amp;path)&#10;                .into_iter()&#10;                .map(|(id, elem)| match self.serializer.deserialize::&lt;V&gt;(&amp;elem) {&#10;                    Ok(deserialized_value) =&gt; (id, deserialized_value),&#10;                    Err(err) =&gt; panic!(&#10;                        &quot;Failed to deserialize neighboring value from device at path {:?}: {}&quot;,&#10;                        path, err&#10;                    ),&#10;                })&#10;                .collect(),&#10;        );&#10;        let serialized_value = match self.serializer.serialize(&amp;value) {&#10;            Ok(val) =&gt; val,&#10;            Err(err) =&gt; panic!(&quot;Failed to serialize neighboring value: {}&quot;, err),&#10;        };&#10;        self.outbound.append(path, serialized_value);&#10;        self.alignment_stack.unalign();&#10;        result&#10;    }&#10;&#10;    fn repeat&lt;V, F&gt;(&amp;mut self, initial: V, evolution: F) -&gt; V&#10;    where&#10;        V: Clone + 'static,&#10;        F: FnOnce(V, &amp;mut Self) -&gt; V,&#10;    {&#10;        self.alignment_stack.align(&quot;repeat&quot;);&#10;        let current_path = Path::new(self.alignment_stack.current_path());&#10;        let previous_state = match self.state.get::&lt;V&gt;(&amp;current_path) {&#10;            Some(value) =&gt; value.clone(),&#10;            None =&gt; initial.clone(),&#10;        };&#10;        let updated_state = evolution(previous_state, self);&#10;        self.state&#10;            .insert(current_path, Box::new(updated_state.clone()));&#10;        self.alignment_stack.unalign();&#10;        updated_state&#10;    }&#10;&#10;    fn branch&lt;V, Th, El&gt;(&amp;mut self, condition: bool, th: Th, el: El) -&gt; V&#10;    where&#10;        Th: FnOnce(&amp;mut Self) -&gt; V,&#10;        El: FnOnce(&amp;mut Self) -&gt; V,&#10;    {&#10;        self.alignment_stack.align(format!(&quot;branch/{}&quot;, condition));&#10;        let result = if condition { th(self) } else { el(self) };&#10;        self.alignment_stack.unalign();&#10;        result&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod tests {&#10;    use super::*;&#10;    use serde::{Serialize, Deserialize};&#10;    use alloc::vec::Vec;&#10;    use alloc::boxed::Box;&#10;&#10;    #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]&#10;    struct DummySerializer;&#10;    impl Serializer for DummySerializer {&#10;        type Error = core::convert::Infallible;&#10;        fn serialize&lt;T: Serialize&gt;(&amp;self, value: &amp;T) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {&#10;            Ok(Vec::new()) // Non fa nulla&#10;        }&#10;        fn deserialize&lt;T: for&lt;'de&gt; Deserialize&lt;'de&gt;&gt;(&amp;self, _data: &amp;[u8]) -&gt; Result&lt;T, Self::Error&gt; {&#10;            unreachable!(&quot;Non usato nei test base&quot;)&#10;        }&#10;    }&#10;&#10;    #[test]&#10;    fn test_vm_new() {&#10;        let vm = VM::new(42u32, DummySerializer);&#10;        assert_eq!(vm.local_id, 42u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_vm_new_with_state() {&#10;        let state = State::default();&#10;        let vm = VM::new_with_state(1u32, DummySerializer, state);&#10;        assert_eq!(vm.local_id, 1u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_repeat_evolves_state() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let res1 = vm.repeat(0i32, |prev, _| prev + 1);&#10;        let res2 = vm.repeat(0i32, |prev, _| prev + 1);&#10;        assert_eq!(res1, 1);&#10;        assert_eq!(res2, 2);&#10;    }&#10;&#10;    #[test]&#10;    fn test_branch_true() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let result = vm.branch(true, |_| &quot;vero&quot;, |_| &quot;falso&quot;);&#10;        assert_eq!(result, &quot;vero&quot;);&#10;    }&#10;&#10;    #[test]&#10;    fn test_branch_false() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let result = vm.branch(false, |_| &quot;vero&quot;, |_| &quot;falso&quot;);&#10;        assert_eq!(result, &quot;falso&quot;);&#10;    }&#10;&#10;    #[test]&#10;    fn test_neighboring_local_value() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let field = vm.neighboring(123i32);&#10;        assert_eq!(field.local_value(), &amp;123i32);&#10;        assert_eq!(field.neighbors().len(), 0);&#10;    }&#10;&#10;    #[test]&#10;    fn test_get_outbound() {&#10;        let vm = VM::new(1u32, DummySerializer);&#10;        let outbound = vm.get_outbound();&#10;        assert_eq!(outbound, Vec::new());&#10;    }&#10;}" />
              <option name="updatedContent" value="use crate::rufi::alignment::alignment_stack::AlignmentStack;&#10;use crate::rufi::data::field::Field;&#10;use crate::rufi::data::state::State;&#10;use crate::rufi::messages::inbound::InboundMessage;&#10;use crate::rufi::messages::outbound::OutboundMessage;&#10;use crate::rufi::messages::path::Path;&#10;use crate::rufi::messages::serializer::Serializer;&#10;use alloc::boxed::Box;&#10;use alloc::format;&#10;use alloc::vec::Vec;&#10;use core::hash::Hash;&#10;use serde::{Deserialize, Serialize};&#10;&#10;pub trait Aggregate&lt;Id: Ord + Hash + Copy + Serialize&gt; {&#10;    fn neighboring&lt;V&gt;(&amp;mut self, value: V) -&gt; Field&lt;Id, V&gt;&#10;    where&#10;        V: Serialize + for&lt;'de&gt; Deserialize&lt;'de&gt; + Clone + 'static;&#10;&#10;    fn repeat&lt;V, F&gt;(&amp;mut self, initial: V, evolution: F) -&gt; V&#10;    where&#10;        V: Clone + 'static,&#10;        F: FnOnce(V, &amp;mut Self) -&gt; V;&#10;&#10;    fn branch&lt;V, Th, El&gt;(&amp;mut self, condition: bool, th: Th, el: El) -&gt; V&#10;    where&#10;        Th: FnOnce(&amp;mut Self) -&gt; V,&#10;        El: FnOnce(&amp;mut Self) -&gt; V;&#10;}&#10;&#10;pub struct VM&lt;Id: Ord + Hash + Copy + Serialize, S: Serializer&gt; {&#10;    pub local_id: Id,&#10;    state: State,&#10;    inbound: InboundMessage&lt;Id&gt;,&#10;    outbound: OutboundMessage&lt;Id&gt;,&#10;    alignment_stack: AlignmentStack,&#10;    serializer: S,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy + Serialize, S: Serializer&gt; VM&lt;Id, S&gt; {&#10;    pub fn new(local_id: Id, serializer: S) -&gt; Self {&#10;        Self {&#10;            local_id,&#10;            state: State::default(),&#10;            inbound: InboundMessage::default(),&#10;            outbound: OutboundMessage::empty(local_id),&#10;            alignment_stack: AlignmentStack::new(),&#10;            serializer,&#10;        }&#10;    }&#10;&#10;    pub fn new_with_state(local_id: Id, serializer: S, state: State) -&gt; Self {&#10;        Self {&#10;            local_id,&#10;            state,&#10;            inbound: InboundMessage::default(),&#10;            outbound: OutboundMessage::empty(local_id),&#10;            alignment_stack: AlignmentStack::new(),&#10;            serializer,&#10;        }&#10;    }&#10;&#10;    pub fn get_outbound(&amp;self) -&gt; Vec&lt;u8&gt; {&#10;        match self.serializer.serialize(&amp;self.outbound) {&#10;            Ok(serialized) =&gt; serialized,&#10;            Err(err) =&gt; panic!(&quot;Failed to serialize outbound message: {}&quot;, err),&#10;        }&#10;    }&#10;&#10;    pub fn set_inbound(&amp;mut self, inbound: InboundMessage&lt;Id&gt;) {&#10;        self.inbound = inbound;&#10;    }&#10;}&#10;impl&lt;Id: Ord + Hash + Copy + Serialize, S: Serializer&gt; Aggregate&lt;Id&gt; for VM&lt;Id, S&gt; {&#10;    fn neighboring&lt;V&gt;(&amp;mut self, value: V) -&gt; Field&lt;Id, V&gt;&#10;    where&#10;        V: Serialize + for&lt;'de&gt; Deserialize&lt;'de&gt; + Clone + 'static,&#10;    {&#10;        self.alignment_stack.align(&quot;neighboring&quot;);&#10;        let path = Path::new(self.alignment_stack.current_path());&#10;        let result: Field&lt;Id, V&gt; = Field::new(&#10;            value.clone(),&#10;            self.inbound&#10;                .get_at_path(&amp;path)&#10;                .into_iter()&#10;                .map(|(id, elem)| match self.serializer.deserialize::&lt;V&gt;(&amp;elem) {&#10;                    Ok(deserialized_value) =&gt; (id, deserialized_value),&#10;                    Err(err) =&gt; panic!(&#10;                        &quot;Failed to deserialize neighboring value from device at path {:?}: {}&quot;,&#10;                        path, err&#10;                    ),&#10;                })&#10;                .collect(),&#10;        );&#10;        let serialized_value = match self.serializer.serialize(&amp;value) {&#10;            Ok(val) =&gt; val,&#10;            Err(err) =&gt; panic!(&quot;Failed to serialize neighboring value: {}&quot;, err),&#10;        };&#10;        self.outbound.append(path, serialized_value);&#10;        self.alignment_stack.unalign();&#10;        result&#10;    }&#10;&#10;    fn repeat&lt;V, F&gt;(&amp;mut self, initial: V, evolution: F) -&gt; V&#10;    where&#10;        V: Clone + 'static,&#10;        F: FnOnce(V, &amp;mut Self) -&gt; V,&#10;    {&#10;        self.alignment_stack.align(&quot;repeat&quot;);&#10;        let current_path = Path::new(self.alignment_stack.current_path());&#10;        let previous_state = match self.state.get::&lt;V&gt;(&amp;current_path) {&#10;            Some(value) =&gt; value.clone(),&#10;            None =&gt; initial.clone(),&#10;        };&#10;        let updated_state = evolution(previous_state, self);&#10;        self.state&#10;            .insert(current_path, Box::new(updated_state.clone()));&#10;        self.alignment_stack.unalign();&#10;        updated_state&#10;    }&#10;&#10;    fn branch&lt;V, Th, El&gt;(&amp;mut self, condition: bool, th: Th, el: El) -&gt; V&#10;    where&#10;        Th: FnOnce(&amp;mut Self) -&gt; V,&#10;        El: FnOnce(&amp;mut Self) -&gt; V,&#10;    {&#10;        self.alignment_stack.align(format!(&quot;branch/{}&quot;, condition));&#10;        let result = if condition { th(self) } else { el(self) };&#10;        self.alignment_stack.unalign();&#10;        result&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod tests {&#10;    use super::*;&#10;    use serde::{Serialize, Deserialize};&#10;    use alloc::vec::Vec;&#10;    use alloc::boxed::Box;&#10;&#10;    #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]&#10;    struct DummySerializer;&#10;    impl Serializer for DummySerializer {&#10;        type Error = core::convert::Infallible;&#10;        fn serialize&lt;T: Serialize&gt;(&amp;self, value: &amp;T) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {&#10;            Ok(Vec::new()) // Non fa nulla&#10;        }&#10;        fn deserialize&lt;T: for&lt;'de&gt; Deserialize&lt;'de&gt;&gt;(&amp;self, _data: &amp;[u8]) -&gt; Result&lt;T, Self::Error&gt; {&#10;            unreachable!(&quot;Non usato nei test base&quot;)&#10;        }&#10;    }&#10;&#10;    #[test]&#10;    fn test_vm_new() {&#10;        let vm = VM::new(42u32, DummySerializer);&#10;        assert_eq!(vm.local_id, 42u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_vm_new_with_state() {&#10;        let state = State::default();&#10;        let vm = VM::new_with_state(1u32, DummySerializer, state);&#10;        assert_eq!(vm.local_id, 1u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_repeat_evolves_state() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let res1 = vm.repeat(0i32, |prev, _| prev + 1);&#10;        let res2 = vm.repeat(0i32, |prev, _| prev + 1);&#10;        assert_eq!(res1, 1);&#10;        assert_eq!(res2, 2);&#10;    }&#10;&#10;    #[test]&#10;    fn test_branch_true() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let result = vm.branch(true, |_| &quot;vero&quot;, |_| &quot;falso&quot;);&#10;        assert_eq!(result, &quot;vero&quot;);&#10;    }&#10;&#10;    #[test]&#10;    fn test_branch_false() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let result = vm.branch(false, |_| &quot;vero&quot;, |_| &quot;falso&quot;);&#10;        assert_eq!(result, &quot;falso&quot;);&#10;    }&#10;&#10;    #[test]&#10;    fn test_neighboring_local_value() {&#10;        let mut vm = VM::new(1u32, DummySerializer);&#10;        let field = vm.neighboring(123i32);&#10;        assert_eq!(field.local_value(), &amp;123i32);&#10;        assert_eq!(field.neighbors().len(), 0);&#10;    }&#10;&#10;    #[test]&#10;    fn test_get_outbound() {&#10;        let vm = VM::new(1u32, DummySerializer);&#10;        let outbound = vm.get_outbound();&#10;        assert_eq!(outbound, Vec::new());&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/rufi/messages.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/rufi/messages.rs" />
              <option name="originalContent" value="use alloc::boxed::Box;&#10;use alloc::collections::BTreeMap;&#10;use alloc::collections::BTreeSet;&#10;use alloc::string::String;&#10;use alloc::string::ToString;&#10;use alloc::vec::Vec;&#10;use core::any::Any;&#10;use core::hash::Hash;&#10;&#10;#[derive(Debug)]&#10;pub struct InboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    underlying: BTreeMap&lt;Id, ValueTree&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; InboundMessage&lt;Id&gt; {&#10;    pub fn new(underlying: BTreeMap&lt;Id, ValueTree&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get(&amp;self, id: &amp;Id) -&gt; Option&lt;&amp;ValueTree&gt; {&#10;        self.underlying.get(id)&#10;    }&#10;&#10;    pub fn get_at_path&lt;'a, V&gt;(&amp;'a self, path: &amp;Path) -&gt; BTreeMap&lt;Id, &amp;'a V&gt;&#10;    where&#10;        V: 'static,&#10;    {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| value_tree.get::&lt;V&gt;(path).map(|value| (*id, value)))&#10;            .collect()&#10;    }&#10;&#10;    pub fn devices_at_path(&amp;self, path: &amp;Path) -&gt; BTreeSet&lt;Id&gt; {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| {&#10;                if value_tree.get::&lt;()&gt;(path).is_some() {&#10;                    Some(*id)&#10;                } else {&#10;                    None&#10;                }&#10;            })&#10;            .collect()&#10;    }&#10;}&#10;impl &lt;Id: Ord + Hash + Copy&gt; Default for InboundMessage&lt;Id&gt; {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct OutboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    pub sender: Id,&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; OutboundMessage&lt;Id&gt; {&#10;    pub fn empty(sender: Id) -&gt; Self {&#10;        Self {&#10;            sender,&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn append&lt;V: Any&gt;(&amp;mut self, path: Path, value: V)&#10;    {&#10;        self.underlying.insert(path, Box::new(value));&#10;    }&#10;&#10;    pub fn get&lt;V: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;V&gt;&#10;    {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;V&gt;())&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct ValueTree {&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl ValueTree {&#10;    pub fn empty() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn new(underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get&lt;T: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;T&gt; {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;T&gt;())&#10;    }&#10;}&#10;&#10;pub trait Exportable&lt;Id: Ord + Hash + Copy&gt; {&#10;    fn export(&amp;self) -&gt; OutboundMessage&lt;Id&gt;;&#10;}&#10;&#10;#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone)]&#10;pub struct Path {&#10;    tokens: Vec&lt;String&gt;,&#10;}&#10;&#10;impl Path {&#10;    pub fn new&lt;T: ToString&gt;(tokens: Vec&lt;T&gt;) -&gt; Self {&#10;        Self {&#10;            tokens: tokens.into_iter().map(|t| t.to_string()).collect(),&#10;        }&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod tests {&#10;    use super::*;&#10;&#10;    fn make_path(tokens: &amp;[&amp;str]) -&gt; Path {&#10;        Path::new(tokens.to_vec())&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_equality_and_hash() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;a&quot;, &quot;c&quot;]);&#10;        assert_eq!(p1, p2);&#10;        assert_ne!(p1, p3);&#10;&#10;        let mut set = BTreeSet::new();&#10;        set.insert(p1);&#10;        assert!(set.contains(&amp;p2));&#10;        assert!(!set.contains(&amp;p3));&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_ordering() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;b&quot;]);&#10;        assert!(p1 &lt; p2);&#10;        assert!(p2 &lt; p3);&#10;    }&#10;&#10;    #[test]&#10;    fn test_outbound_message_append_and_get() {&#10;        let mut msg = OutboundMessage::empty(42u32);&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        msg.append(path.clone(), 123i32);&#10;&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;path), Some(&amp;123));&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;make_path(&amp;[&quot;bar&quot;])), None);&#10;        assert_eq!(msg.sender, 42u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_get_and_new() {&#10;        let mut underlying = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;x&quot;]);&#10;        underlying.insert(path.clone(), Box::new(99u8) as Box&lt;dyn Any&gt;);&#10;        let vt = ValueTree::new(underlying);&#10;&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;path), Some(&amp;99u8));&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;make_path(&amp;[&quot;y&quot;])), None);&#10;        assert_eq!(vt.get::&lt;i32&gt;(&amp;path), None);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_empty() {&#10;        let vt = ValueTree::empty();&#10;        let path = make_path(&amp;[&quot;z&quot;]);&#10;        assert!(vt.get::&lt;u8&gt;(&amp;path).is_none());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_get_and_get_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying.insert(path.clone(), Box::new(1u32));&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying.insert(path.clone(), Box::new(2u32));&#10;        vt_map.insert(10u8, vt1);&#10;        vt_map.insert(20u8, vt2);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;&#10;        // get&#10;        assert!(inbound.get(&amp;10u8).is_some());&#10;        assert!(inbound.get(&amp;30u8).is_none());&#10;&#10;        // get_at_path&#10;        let map = inbound.get_at_path::&lt;u32&gt;(&amp;path);&#10;        assert_eq!(map.len(), 2);&#10;        assert_eq!(*map.get(&amp;10u8).unwrap(), &amp;1u32);&#10;        assert_eq!(*map.get(&amp;20u8).unwrap(), &amp;2u32);&#10;&#10;        // get_at_path with wrong type&#10;        let map_wrong = inbound.get_at_path::&lt;i32&gt;(&amp;path);&#10;        assert!(map_wrong.is_empty());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_devices_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let vt3 = ValueTree::empty();&#10;        // vt3 does not have the path&#10;&#10;        vt_map.insert(1u8, vt1);&#10;        vt_map.insert(2u8, vt2);&#10;        vt_map.insert(3u8, vt3);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;        let devices = inbound.devices_at_path(&amp;path);&#10;&#10;        assert_eq!(devices.len(), 2);&#10;        assert!(devices.contains(&amp;1u8));&#10;        assert!(devices.contains(&amp;2u8));&#10;        assert!(!devices.contains(&amp;3u8));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="use alloc::boxed::Box;&#10;use alloc::collections::BTreeMap;&#10;use alloc::collections::BTreeSet;&#10;use alloc::string::String;&#10;use alloc::string::ToString;&#10;use alloc::vec::Vec;&#10;use core::any::Any;&#10;use core::hash::Hash;&#10;&#10;#[derive(Debug)]&#10;pub struct InboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    underlying: BTreeMap&lt;Id, ValueTree&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; InboundMessage&lt;Id&gt; {&#10;    pub fn new(underlying: BTreeMap&lt;Id, ValueTree&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get(&amp;self, id: &amp;Id) -&gt; Option&lt;&amp;ValueTree&gt; {&#10;        self.underlying.get(id)&#10;    }&#10;&#10;    pub fn get_at_path&lt;'a, V&gt;(&amp;'a self, path: &amp;Path) -&gt; BTreeMap&lt;Id, &amp;'a V&gt;&#10;    where&#10;        V: 'static,&#10;    {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| value_tree.get::&lt;V&gt;(path).map(|value| (*id, value)))&#10;            .collect()&#10;    }&#10;&#10;    pub fn devices_at_path(&amp;self, path: &amp;Path) -&gt; BTreeSet&lt;Id&gt; {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| {&#10;                if value_tree.get::&lt;()&gt;(path).is_some() {&#10;                    Some(*id)&#10;                } else {&#10;                    None&#10;                }&#10;            })&#10;            .collect()&#10;    }&#10;}&#10;impl &lt;Id: Ord + Hash + Copy&gt; Default for InboundMessage&lt;Id&gt; {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct OutboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    pub sender: Id,&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; OutboundMessage&lt;Id&gt; {&#10;    pub fn empty(sender: Id) -&gt; Self {&#10;        Self {&#10;            sender,&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn append&lt;V: Any&gt;(&amp;mut self, path: Path, value: V)&#10;    {&#10;        self.underlying.insert(path, Box::new(value));&#10;    }&#10;&#10;    pub fn get&lt;V: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;V&gt;&#10;    {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;V&gt;())&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct ValueTree {&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl ValueTree {&#10;    pub fn empty() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn new(underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get&lt;T: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;T&gt; {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;T&gt;())&#10;    }&#10;}&#10;&#10;pub trait Exportable&lt;Id: Ord + Hash + Copy&gt; {&#10;    fn export(&amp;self) -&gt; OutboundMessage&lt;Id&gt;;&#10;}&#10;&#10;#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone)]&#10;pub struct Path {&#10;    tokens: Vec&lt;String&gt;,&#10;}&#10;&#10;impl Path {&#10;    pub fn new&lt;T: ToString&gt;(tokens: Vec&lt;T&gt;) -&gt; Self {&#10;        Self {&#10;            tokens: tokens.into_iter().map(|t| t.to_string()).collect(),&#10;        }&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod tests {&#10;    use super::*;&#10;&#10;    fn make_path(tokens: &amp;[&amp;str]) -&gt; Path {&#10;        Path::new(tokens.to_vec())&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_equality_and_hash() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;a&quot;, &quot;c&quot;]);&#10;        assert_eq!(p1, p2);&#10;        assert_ne!(p1, p3);&#10;&#10;        let mut set = BTreeSet::new();&#10;        set.insert(p1);&#10;        assert!(set.contains(&amp;p2));&#10;        assert!(!set.contains(&amp;p3));&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_ordering() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;b&quot;]);&#10;        assert!(p1 &lt; p2);&#10;        assert!(p2 &lt; p3);&#10;    }&#10;&#10;    #[test]&#10;    fn test_outbound_message_append_and_get() {&#10;        let mut msg = OutboundMessage::empty(42u32);&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        msg.append(path.clone(), 123i32);&#10;&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;path), Some(&amp;123));&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;make_path(&amp;[&quot;bar&quot;])), None);&#10;        assert_eq!(msg.sender, 42u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_get_and_new() {&#10;        let mut underlying = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;x&quot;]);&#10;        underlying.insert(path.clone(), Box::new(99u8) as Box&lt;dyn Any&gt;);&#10;        let vt = ValueTree::new(underlying);&#10;&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;path), Some(&amp;99u8));&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;make_path(&amp;[&quot;y&quot;])), None);&#10;        assert_eq!(vt.get::&lt;i32&gt;(&amp;path), None);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_empty() {&#10;        let vt = ValueTree::empty();&#10;        let path = make_path(&amp;[&quot;z&quot;]);&#10;        assert!(vt.get::&lt;u8&gt;(&amp;path).is_none());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_get_and_get_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying.insert(path.clone(), Box::new(1u32));&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying.insert(path.clone(), Box::new(2u32));&#10;        vt_map.insert(10u8, vt1);&#10;        vt_map.insert(20u8, vt2);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;&#10;        // get&#10;        assert!(inbound.get(&amp;10u8).is_some());&#10;        assert!(inbound.get(&amp;30u8).is_none());&#10;&#10;        // get_at_path&#10;        let map = inbound.get_at_path::&lt;u32&gt;(&amp;path);&#10;        assert_eq!(map.len(), 2);&#10;        assert_eq!(*map.get(&amp;10u8).unwrap(), &amp;1u32);&#10;        assert_eq!(*map.get(&amp;20u8).unwrap(), &amp;2u32);&#10;&#10;        // get_at_path with wrong type&#10;        let map_wrong = inbound.get_at_path::&lt;i32&gt;(&amp;path);&#10;        assert!(map_wrong.is_empty());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_devices_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let vt3 = ValueTree::empty();&#10;        // vt3 does not have the path&#10;&#10;        vt_map.insert(1u8, vt1);&#10;        vt_map.insert(2u8, vt2);&#10;        vt_map.insert(3u8, vt3);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;        let devices = inbound.devices_at_path(&amp;path);&#10;&#10;        assert_eq!(devices.len(), 2);&#10;        assert!(devices.contains(&amp;1u8));&#10;        assert!(devices.contains(&amp;2u8));&#10;        assert!(!devices.contains(&amp;3u8));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>