<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/rufi/messages.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/rufi/messages.rs" />
              <option name="originalContent" value="use alloc::boxed::Box;&#10;use alloc::collections::BTreeMap;&#10;use alloc::collections::BTreeSet;&#10;use alloc::string::String;&#10;use alloc::string::ToString;&#10;use alloc::vec::Vec;&#10;use core::any::Any;&#10;use core::hash::Hash;&#10;&#10;#[derive(Debug)]&#10;pub struct InboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    underlying: BTreeMap&lt;Id, ValueTree&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; InboundMessage&lt;Id&gt; {&#10;    pub fn new(underlying: BTreeMap&lt;Id, ValueTree&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get(&amp;self, id: &amp;Id) -&gt; Option&lt;&amp;ValueTree&gt; {&#10;        self.underlying.get(id)&#10;    }&#10;&#10;    pub fn get_at_path&lt;'a, V&gt;(&amp;'a self, path: &amp;Path) -&gt; BTreeMap&lt;Id, &amp;'a V&gt;&#10;    where&#10;        V: 'static,&#10;    {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| value_tree.get::&lt;V&gt;(path).map(|value| (*id, value)))&#10;            .collect()&#10;    }&#10;&#10;    pub fn devices_at_path(&amp;self, path: &amp;Path) -&gt; BTreeSet&lt;Id&gt; {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| {&#10;                if value_tree.get::&lt;()&gt;(path).is_some() {&#10;                    Some(*id)&#10;                } else {&#10;                    None&#10;                }&#10;            })&#10;            .collect()&#10;    }&#10;}&#10;impl &lt;Id: Ord + Hash + Copy&gt; Default for InboundMessage&lt;Id&gt; {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct OutboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    pub sender: Id,&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; OutboundMessage&lt;Id&gt; {&#10;    pub fn empty(sender: Id) -&gt; Self {&#10;        Self {&#10;            sender,&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn append&lt;V: Any&gt;(&amp;mut self, path: Path, value: V)&#10;    {&#10;        self.underlying.insert(path, Box::new(value));&#10;    }&#10;&#10;    pub fn get&lt;V: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;V&gt;&#10;    {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;V&gt;())&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct ValueTree {&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl ValueTree {&#10;    pub fn empty() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn new(underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get&lt;T: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;T&gt; {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;T&gt;())&#10;    }&#10;}&#10;&#10;pub trait Exportable&lt;Id: Ord + Hash + Copy&gt; {&#10;    fn export(&amp;self) -&gt; OutboundMessage&lt;Id&gt;;&#10;}&#10;&#10;#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone)]&#10;pub struct Path {&#10;    tokens: Vec&lt;String&gt;,&#10;}&#10;&#10;impl Path {&#10;    pub fn new&lt;T: ToString&gt;(tokens: Vec&lt;T&gt;) -&gt; Self {&#10;        Self {&#10;            tokens: tokens.into_iter().map(|t| t.to_string()).collect(),&#10;        }&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod tests {&#10;    use super::*;&#10;&#10;    fn make_path(tokens: &amp;[&amp;str]) -&gt; Path {&#10;        Path::new(tokens.to_vec())&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_equality_and_hash() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;a&quot;, &quot;c&quot;]);&#10;        assert_eq!(p1, p2);&#10;        assert_ne!(p1, p3);&#10;&#10;        let mut set = BTreeSet::new();&#10;        set.insert(p1);&#10;        assert!(set.contains(&amp;p2));&#10;        assert!(!set.contains(&amp;p3));&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_ordering() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;b&quot;]);&#10;        assert!(p1 &lt; p2);&#10;        assert!(p2 &lt; p3);&#10;    }&#10;&#10;    #[test]&#10;    fn test_outbound_message_append_and_get() {&#10;        let mut msg = OutboundMessage::empty(42u32);&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        msg.append(path.clone(), 123i32);&#10;&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;path), Some(&amp;123));&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;make_path(&amp;[&quot;bar&quot;])), None);&#10;        assert_eq!(msg.sender, 42u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_get_and_new() {&#10;        let mut underlying = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;x&quot;]);&#10;        underlying.insert(path.clone(), Box::new(99u8) as Box&lt;dyn Any&gt;);&#10;        let vt = ValueTree::new(underlying);&#10;&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;path), Some(&amp;99u8));&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;make_path(&amp;[&quot;y&quot;])), None);&#10;        assert_eq!(vt.get::&lt;i32&gt;(&amp;path), None);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_empty() {&#10;        let vt = ValueTree::empty();&#10;        let path = make_path(&amp;[&quot;z&quot;]);&#10;        assert!(vt.get::&lt;u8&gt;(&amp;path).is_none());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_get_and_get_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying.insert(path.clone(), Box::new(1u32));&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying.insert(path.clone(), Box::new(2u32));&#10;        vt_map.insert(10u8, vt1);&#10;        vt_map.insert(20u8, vt2);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;&#10;        // get&#10;        assert!(inbound.get(&amp;10u8).is_some());&#10;        assert!(inbound.get(&amp;30u8).is_none());&#10;&#10;        // get_at_path&#10;        let map = inbound.get_at_path::&lt;u32&gt;(&amp;path);&#10;        assert_eq!(map.len(), 2);&#10;        assert_eq!(*map.get(&amp;10u8).unwrap(), &amp;1u32);&#10;        assert_eq!(*map.get(&amp;20u8).unwrap(), &amp;2u32);&#10;&#10;        // get_at_path with wrong type&#10;        let map_wrong = inbound.get_at_path::&lt;i32&gt;(&amp;path);&#10;        assert!(map_wrong.is_empty());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_devices_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let vt3 = ValueTree::empty();&#10;        // vt3 does not have the path&#10;&#10;        vt_map.insert(1u8, vt1);&#10;        vt_map.insert(2u8, vt2);&#10;        vt_map.insert(3u8, vt3);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;        let devices = inbound.devices_at_path(&amp;path);&#10;&#10;        assert_eq!(devices.len(), 2);&#10;        assert!(devices.contains(&amp;1u8));&#10;        assert!(devices.contains(&amp;2u8));&#10;        assert!(!devices.contains(&amp;3u8));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="use alloc::boxed::Box;&#10;use alloc::collections::BTreeMap;&#10;use alloc::collections::BTreeSet;&#10;use alloc::string::String;&#10;use alloc::string::ToString;&#10;use alloc::vec::Vec;&#10;use core::any::Any;&#10;use core::hash::Hash;&#10;&#10;#[derive(Debug)]&#10;pub struct InboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    underlying: BTreeMap&lt;Id, ValueTree&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; InboundMessage&lt;Id&gt; {&#10;    pub fn new(underlying: BTreeMap&lt;Id, ValueTree&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get(&amp;self, id: &amp;Id) -&gt; Option&lt;&amp;ValueTree&gt; {&#10;        self.underlying.get(id)&#10;    }&#10;&#10;    pub fn get_at_path&lt;'a, V&gt;(&amp;'a self, path: &amp;Path) -&gt; BTreeMap&lt;Id, &amp;'a V&gt;&#10;    where&#10;        V: 'static,&#10;    {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| value_tree.get::&lt;V&gt;(path).map(|value| (*id, value)))&#10;            .collect()&#10;    }&#10;&#10;    pub fn devices_at_path(&amp;self, path: &amp;Path) -&gt; BTreeSet&lt;Id&gt; {&#10;        self.underlying&#10;            .iter()&#10;            .filter_map(|(id, value_tree)| {&#10;                if value_tree.get::&lt;()&gt;(path).is_some() {&#10;                    Some(*id)&#10;                } else {&#10;                    None&#10;                }&#10;            })&#10;            .collect()&#10;    }&#10;}&#10;impl &lt;Id: Ord + Hash + Copy&gt; Default for InboundMessage&lt;Id&gt; {&#10;    fn default() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct OutboundMessage&lt;Id: Ord + Hash + Copy&gt; {&#10;    pub sender: Id,&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl&lt;Id: Ord + Hash + Copy&gt; OutboundMessage&lt;Id&gt; {&#10;    pub fn empty(sender: Id) -&gt; Self {&#10;        Self {&#10;            sender,&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn append&lt;V: Any&gt;(&amp;mut self, path: Path, value: V)&#10;    {&#10;        self.underlying.insert(path, Box::new(value));&#10;    }&#10;&#10;    pub fn get&lt;V: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;V&gt;&#10;    {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;V&gt;())&#10;    }&#10;}&#10;&#10;#[derive(Debug)]&#10;pub struct ValueTree {&#10;    underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;,&#10;}&#10;impl ValueTree {&#10;    pub fn empty() -&gt; Self {&#10;        Self {&#10;            underlying: BTreeMap::new(),&#10;        }&#10;    }&#10;&#10;    pub fn new(underlying: BTreeMap&lt;Path, Box&lt;dyn Any&gt;&gt;) -&gt; Self {&#10;        Self { underlying }&#10;    }&#10;&#10;    pub fn get&lt;T: Any&gt;(&amp;self, path: &amp;Path) -&gt; Option&lt;&amp;T&gt; {&#10;        self.underlying&#10;            .get(path)&#10;            .and_then(|value| value.downcast_ref::&lt;T&gt;())&#10;    }&#10;}&#10;&#10;pub trait Exportable&lt;Id: Ord + Hash + Copy&gt; {&#10;    fn export(&amp;self) -&gt; OutboundMessage&lt;Id&gt;;&#10;}&#10;&#10;#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone)]&#10;pub struct Path {&#10;    tokens: Vec&lt;String&gt;,&#10;}&#10;&#10;impl Path {&#10;    pub fn new&lt;T: ToString&gt;(tokens: Vec&lt;T&gt;) -&gt; Self {&#10;        Self {&#10;            tokens: tokens.into_iter().map(|t| t.to_string()).collect(),&#10;        }&#10;    }&#10;}&#10;&#10;#[cfg(test)]&#10;mod tests {&#10;    use super::*;&#10;&#10;    fn make_path(tokens: &amp;[&amp;str]) -&gt; Path {&#10;        Path::new(tokens.to_vec())&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_equality_and_hash() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;a&quot;, &quot;c&quot;]);&#10;        assert_eq!(p1, p2);&#10;        assert_ne!(p1, p3);&#10;&#10;        let mut set = BTreeSet::new();&#10;        set.insert(p1);&#10;        assert!(set.contains(&amp;p2));&#10;        assert!(!set.contains(&amp;p3));&#10;    }&#10;&#10;    #[test]&#10;    fn test_path_ordering() {&#10;        let p1 = make_path(&amp;[&quot;a&quot;]);&#10;        let p2 = make_path(&amp;[&quot;a&quot;, &quot;b&quot;]);&#10;        let p3 = make_path(&amp;[&quot;b&quot;]);&#10;        assert!(p1 &lt; p2);&#10;        assert!(p2 &lt; p3);&#10;    }&#10;&#10;    #[test]&#10;    fn test_outbound_message_append_and_get() {&#10;        let mut msg = OutboundMessage::empty(42u32);&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        msg.append(path.clone(), 123i32);&#10;&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;path), Some(&amp;123));&#10;        assert_eq!(msg.get::&lt;i32&gt;(&amp;make_path(&amp;[&quot;bar&quot;])), None);&#10;        assert_eq!(msg.sender, 42u32);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_get_and_new() {&#10;        let mut underlying = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;x&quot;]);&#10;        underlying.insert(path.clone(), Box::new(99u8) as Box&lt;dyn Any&gt;);&#10;        let vt = ValueTree::new(underlying);&#10;&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;path), Some(&amp;99u8));&#10;        assert_eq!(vt.get::&lt;u8&gt;(&amp;make_path(&amp;[&quot;y&quot;])), None);&#10;        assert_eq!(vt.get::&lt;i32&gt;(&amp;path), None);&#10;    }&#10;&#10;    #[test]&#10;    fn test_value_tree_empty() {&#10;        let vt = ValueTree::empty();&#10;        let path = make_path(&amp;[&quot;z&quot;]);&#10;        assert!(vt.get::&lt;u8&gt;(&amp;path).is_none());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_get_and_get_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying.insert(path.clone(), Box::new(1u32));&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying.insert(path.clone(), Box::new(2u32));&#10;        vt_map.insert(10u8, vt1);&#10;        vt_map.insert(20u8, vt2);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;&#10;        // get&#10;        assert!(inbound.get(&amp;10u8).is_some());&#10;        assert!(inbound.get(&amp;30u8).is_none());&#10;&#10;        // get_at_path&#10;        let map = inbound.get_at_path::&lt;u32&gt;(&amp;path);&#10;        assert_eq!(map.len(), 2);&#10;        assert_eq!(*map.get(&amp;10u8).unwrap(), &amp;1u32);&#10;        assert_eq!(*map.get(&amp;20u8).unwrap(), &amp;2u32);&#10;&#10;        // get_at_path with wrong type&#10;        let map_wrong = inbound.get_at_path::&lt;i32&gt;(&amp;path);&#10;        assert!(map_wrong.is_empty());&#10;    }&#10;&#10;    #[test]&#10;    fn test_inbound_message_devices_at_path() {&#10;        let mut vt_map = BTreeMap::new();&#10;        let path = make_path(&amp;[&quot;foo&quot;]);&#10;        let mut vt1 = ValueTree::empty();&#10;        vt1.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let mut vt2 = ValueTree::empty();&#10;        vt2.underlying&#10;            .insert(path.clone(), Box::new(()) as Box&lt;dyn Any&gt;);&#10;        let vt3 = ValueTree::empty();&#10;        // vt3 does not have the path&#10;&#10;        vt_map.insert(1u8, vt1);&#10;        vt_map.insert(2u8, vt2);&#10;        vt_map.insert(3u8, vt3);&#10;&#10;        let inbound = InboundMessage::new(vt_map);&#10;        let devices = inbound.devices_at_path(&amp;path);&#10;&#10;        assert_eq!(devices.len(), 2);&#10;        assert!(devices.contains(&amp;1u8));&#10;        assert!(devices.contains(&amp;2u8));&#10;        assert!(!devices.contains(&amp;3u8));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>